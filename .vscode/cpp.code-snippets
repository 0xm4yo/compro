{
    "Template_cpp": {
        "prefix": "tmp_cpp",
        "body": [
            "#include <bits/stdc++.h>",
            "#include <atcoder/all>",
            "",
            "using namespace std;",
            "using namespace atcoder;",
            "using ll = long long;",
            "using ull = unsigned long long;",
            "template <class T> using priority_queue_rev = priority_queue<T, vector<T>, greater<T>>;",
            "",
            "#define rep(i, a, b) for(ll i=a; i<b; i++)",
            "#define rrep(i, a, b) for(ll i=a; i>=b; i--)",
            "#define all(a) (a).begin(), (a).end()",
            "#define smod(n, m) ((((n) % (m)) + (m)) % (m)) // 非負mod",
            "#define YesNo(bool) if(bool){cout<<\"Yes\"<<endl;}else{cout<<\"No\"<<endl;}",
            "",
            "template<typename T> inline bool chmax(T &a, T b) { return ((a < b) ? (a = b, true) : (false)); }",
            "template<typename T> inline bool chmin(T &a, T b) { return ((a > b) ? (a = b, true) : (false)); }",
            "",
            "inline int popcount(int n) { return __builtin_popcount(n); } // 2進数で表した場合に立ってるビット数がいくつか",
            "inline int popcount(ll n) { return __builtin_popcountll(n); }",
            "inline int ctz(int n) { return n != 0 ? __builtin_ctz(n) : -1; } // 2進数で表した場合に 1 の位からいくつ 0 が連なっているか",
            "inline int ctz(ll n) { return n != 0 ? __builtin_ctzll(n) : -1; }",
            "inline int clz(int n) { return n != 0 ? (31 - __builtin_clz(n)) : -1; } // 2進数で表した場合に左側にいくつ 0 を埋める必要があるか",
            "inline int clz(ll n) { return n != 0 ? (63 - __builtin_clzll(n)) : -1; }",
            "",
            "const double PI = 3.141592653589793;",
            "const vector<int> DX = { 1, 0, -1, 0 };",
            "const vector<int> DY = { 0, 1, 0, -1 };",
            "const long long INF = 4004004003104004004LL; // (int)INF = 1010931620;",
            "ll coordinate(ll h, ll w, ll W){ return h*W + w; } // 二次元座標を一次元座標に変換",
			"",
            "#define endl \"\\n\" // インタラクティブの時はコメントアウトする",
            "",
            "int main()",
            "{",
            "    ios::sync_with_stdio(false);",
            "    std::cin.tie(nullptr);",
            "    // cout << fixed << setprecision(18);",
            "    ",
            "    ",
            "    return 0;",
            "}"
            ],
        "description": ""
    }, 

    "integer_digits_cpp": {
        "prefix": "integer_digits",
        "body": [
            "/*",
            "    桁の数を b 進数で取得",
            "    n を b 進数で表記したときの各桁の数字を上位桁から順に並べたリストを返す",
            "*/",
            "vector<int> integer_digits(long long n, int b = 10){",
            "	assert(abs(b) >= 2);",
            "	// n = 0",
            "	if (n == 0) return vector<int>{0};",
            "",
            "	// mod |b| をとって最下位桁から順に決定",
            "	vector<int> res;",
            "	while (n != 0) {",
            "		int d = smod(n, abs(b));",
            "		res.push_back(d);",
            "		n = (n - d) / b;",
            "	}",
            "",
            "	// 上位桁から順になるように並べ直す",
            "	reverse(all(res));",
            "	return res;",
            "}",
        ],
        "description": ""
    },

    "Matrix_cpp": {
        "prefix": "matrix_cpp",
        "body": [
            "// 2次元行列ライブラリ",
            "template<typename T>",
            "struct mat {",
            "    vector<vector<T>> m;",
            "    // コンストラクタ h: 行数、w: 列数、init: 初期値",
            "    mat() : m(vector<vector<T>>()){}",
            "    mat(int h, int w) : m(vector<vector<T>>(h, vector<T>(w))){}",
            "    mat(int h, int w, T init) : m(vector<vector<T>>(h, vector<T>(w, init))){}",
            "    ",
            "    // 添字演算子",
            "    vector<T> operator[](const int i) const { return m[i]; }",
            "    vector<T>& operator[](const int i) { return m[i]; }",
            "    ",
            "    // 行数と列数",
            "    int nrow = m.size();",
            "    int ncol = m[0].size();",
            "",
            "    // 行列・行列の演算",
            "    mat& operator=(const mat& a){",
            "        if (this != &a){ m = a.m; nrow = a.nrow; ncol = a.ncol; }",
            "        return *this;",
            "    }",
            "    mat& operator+=(const mat& a){",
            "        assert(ncol == a.ncol && nrow == a.nrow);",
            "        rep(i, 0, nrow) rep(j, 0, ncol) m[i][j] += a.m[i][j];",
            "        return *this;",
            "    }",
            "    mat& operator-=(const mat& a){",
            "        assert(ncol == a.ncol && nrow == a.nrow);",
            "        rep(i, 0, nrow) rep(j,0, ncol) m[i][j] -= a.m[i][j]; ",
            "        return *this;",
            "    } ",
            "    mat& operator*=(const mat& a){",
            "        assert(ncol == a.nrow);",
            "        mat<T> m2(nrow, a.ncol, 0);",
            "        rep(i, 0, nrow) rep(j, 0, a.ncol) rep(k, 0, ncol){",
            "            m2.m[i][j] += m[i][k] * a.m[k][j];",
            "        }",
            "        ncol = a.ncol;",
            "        rep(i, 0, nrow) m[i].resize(ncol);",
            "        rep(i, 0, nrow) rep(j, 0, ncol) m[i][j] = m2.m[i][j]; ",
            "        return *this;",
            "    }",
            "    mat operator+(const mat& a) const { return mat(*this) += a; }",
            "    mat operator-(const mat& a) const { return mat(*this) -= a; }",
            "    mat operator*(const mat& a) const { return mat(*this) *= a; }",
            "    bool operator==(const mat& a) const {",
            "        if (!(ncol == a.ncol && nrow == a.nrow)) return false;",
            "        bool flag = true;",
            "        rep(i, 0, nrow) rep(j, 0, ncol) if(m[i][j] != a.m[i][j]) flag = false;",
            "        return flag;",
            "    }",
            "",
            "    // 行列・スカラの演算",
            "    mat& operator+=(const T& a){ rep(i, 0, nrow)rep(j, 0, ncol) m[i][j] += a; return *this; }",
            "    mat& operator-=(const T& a){ rep(i, 0, nrow)rep(j, 0, ncol) m[i][j] -= a; return *this; }",
            "    mat& operator*=(const T& a){ rep(i, 0, nrow)rep(j, 0, ncol) m[i][j] *= a; return *this; }",
            "    mat& operator/=(const T& a){ rep(i, 0, nrow)rep(j, 0, ncol) m[i][j] /= a; return *this; }",
            "    mat operator+(const T& a) const { return mat(*this) += a; }",
            "    mat operator-(const T& a) const { return mat(*this) -= a; }",
            "    mat operator*(const T& a) const { return mat(*this) *= a; }",
            "    mat operator/(const T& a) const { return mat(*this) /= a; }",
            "",
            "    // 転置行列",
            "    mat<T> transpose() const {",
            "        mat<T> transposed(ncol, nrow, 0);",
            "        rep(i, 0, nrow) rep(j, 0, ncol) transposed.m[j][i] = m[i][j];",
            "        return transposed;",
            "    }",
            "",
            "    // 行列累乗 正方行列を初期化",
            "    vector<mat<T>> v;",
            "    int MAX_SIZE = 63;",
            "    bool INITIALIZE_POW = false;",
            "    void pow_init(){",
            "        assert(nrow == ncol);",
            "        INITIALIZE_POW = true;",
            "        v.resize(MAX_SIZE, *this);",
            "        rep(i, 1, MAX_SIZE) v[i] = v[i-1]*v[i-1];",
            "    }",
            "",
            "    // 行列累乗 正方行列のk乗を出力",
            "    mat pow(long long k){",
            "        assert(nrow == ncol);",
            "        if (!INITIALIZE_POW) pow_init();",
            "        mat<T> e(nrow, nrow, 0);",
            "        rep(i, 0, nrow) e[i][i] = (T)1;",
            "        mat<T> mk = e;",
            "        rep(i, 0, MAX_SIZE) if (k & (1LL<<i)) mk *= v[i];",
            "        return mk;",
            "    }",
            "",
            "    // 回転 degの数だけ時計回りに90度回転して値を更新",
            "    // https://qiita.com/gnbrganchan/items/47118d45b3af9d5ae9a4",
            "    mat& rot(int deg){",
            "        deg = (deg%4 + 4) % 4;",
            "        mat<T> m2(ncol, nrow);",
            "        if(deg == 1 || deg == 3){",
            "            if (deg == 1) rep(i, 0, nrow)rep(j, 0, ncol) m2.m[j][nrow-i-1] = m[i][j];",
            "            if (deg == 3) rep(i, 0, nrow)rep(j, 0, ncol) m2.m[ncol-j-1][i] = m[i][j];",
            "            swap(ncol, nrow); ",
            "            m.resize(nrow);",
            "            rep(i, 0, nrow) m[i].resize(ncol);",
            "        }else if (deg == 2){",
            "            rep(i, 0, nrow) rep(j, 0, ncol) m2.m[nrow-i-1][ncol-j-1] = m[i][j];",
            "        }else{",
            "            return *this;",
            "        }",
            "        rep(i, 0, nrow) rep(j, 0, ncol) m[i][j] = m2.m[i][j];",
            "        return *this;",
            "    }",
            "",
            "    // 標準出力",
            "    void show(){",
            "        rep(i, 0, nrow) rep(j, 0, ncol){",
            "            if (j != 0) cout << \" \";",
            "            cout << m[i][j];",
            "            if (j == ncol-1) cout << endl;",
            "        }",
            "        return ;",
            "    }",
            "};",
        ],
        "description": ""
    },

    "Matrix": {
        "prefix": "Matrix",
        "body": [
            "// 行列累乗ライブラリ（任意の半環に対応版）",
            "// 1. (R, +) は単位元 0 を持つ可換モノイドを成す:",
            "//      1. (a + b) + c = a + (b + c),",
            "//      2. 0 + a = a + 0 = a,",
            "//      3. a + b = b + a.",
            "// 2. (R, ·) は単位元 1 を持つモノイドを成す:",
            "//      1. (a · b)· c = a ·(b · c),",
            "//      2. 1 · a = a · 1 = a.",
            "// 3. 乗法は加法の上に分配的である:",
            "//      1. a ·(b + c) = (a · b) + (a · c),",
            "//      2. (a + b)· c = (a · c) + (b · c).",
            "// 4. 0-倍は R を零化する:",
            "//      1. 0 · a = a · 0 = 0.",
            "template<typename T, T (*add)(T, T), T (*zero)(), T (*mul)(T, T), T (*one)()>",
            "class Matrix {",
            "private:",
            "    vector<vector<T>> data; // 行列データ",
            "    int rows, cols; // 行数と列数",
            "",
            "public:",
            "    // コンストラクタ",
            "    Matrix(int rows, int cols) : rows(rows), cols(cols) {",
            "        data.resize(rows, vector<T>(cols, zero()));",
            "    }",
            "",
            "    // 添字演算子",
            "    vector<T>& operator[](int index) { return data[index]; }",
            "",
            "    // 加法（行列＋行列）",
            "    Matrix& operator+=(const Matrix& other) {",
            "        assert(rows == other.rows && cols == other.cols);",
            "        for (int i = 0; i < rows; ++i) {",
            "            for (int j = 0; j < cols; ++j) {",
            "                data[i][j] = add(data[i][j], other.data[i][j]);",
            "            }",
            "        }",
            "        return *this;",
            "    }",
            "    Matrix operator+(const Matrix& other) const {",
            "        Matrix result(*this);",
            "        result += other;",
            "        return result;",
            "    }",
            "",
            "    // 乗法（行列・行列）",
            "    Matrix& operator*=(const Matrix& other) {",
            "        assert(cols == other.rows);",
            "        vector<vector<T>> newData(rows, vector<T>(other.cols, zero()));",
            "        for (int i = 0; i < rows; ++i) {",
            "            for (int j = 0; j < other.cols; ++j) {",
            "                for (int k = 0; k < cols; ++k) {",
            "                    newData[i][j] = add(newData[i][j], mul(data[i][k], other.data[k][j]));",
            "                }",
            "            }",
            "        }",
            "        data = newData;",
            "        cols = other.cols;",
            "        return *this;",
            "    }",
            "    Matrix operator*(const Matrix& other) const {",
            "        Matrix result(*this);",
            "        result *= other;",
            "        return result;",
            "    }",
            "    ",
            "    // 行列の冪乗",
            "    Matrix pow(long long exponent) const {",
            "        assert(rows == cols); // 正方行列であることを確認",
            "        // 単位行列で初期化",
            "        Matrix result(rows, cols);",
            "        for (int i = 0; i < rows; ++i) {",
            "            result.data[i][i] = one();",
            "        }",
            "        if (exponent == 0) return result;",
            "",
            "        Matrix base = *this;",
            "        while (exponent > 0) {",
            "            if (exponent & 1) {",
            "                result = result * base;",
            "            }",
            "            base = base * base;",
            "            exponent >>= 1;",
            "        }",
            "        return result;",
            "    }",
            "",
            "    // 行列の表示",
            "    void print() const {",
            "        for (int i = 0; i < rows; ++i) {",
            "            for (int j = 0; j < cols; ++j) {",
            "                cout << data[i][j] << \" \";",
            "            }",
            "            cout << endl;",
            "        }",
            "    }",
            "};",
            "",
            "// ADD_MUL_semi-ring",
            "// long long add000(long long x, long long y) { return x + y; }",
            "// long long zero000() { return 0LL; }",
            "// long long mul000(long long x, long long y) { return x * y; }",
            "// long long one000() { return 1LL; }",
            "// #define ADD_MUL_semiring_000 long long, add000, zero000, mul000, one000",
            "",
            "// ADD_MUL_semi-ring mint",
            "// verify: https://atcoder.jp/contests/abc009/tasks/abc009_4",
            "using mint = modint;",
            "mint add001(mint x, mint y) { return x + y; }",
            "mint zero001() { return 0; }",
            "mint mul001(mint x, mint y) { return x * y; }",
            "mint one001() { return 1; }",
            "#define ADD_MUL_semiring mint, add001, zero001, mul001, one001",
            "",
            "",
            "// XOR_AND_semi-ring",
            "// verify: https://atcoder.jp/contests/abc009/tasks/abc009_4",
            "long long add002(long long x, long long y) { return x ^ y; }",
            "long long zero002() { return 0LL; }",
            "long long mul002(long long x, long long y) { return x & y; }",
            "long long one002() { return ~0LL; }",
            "#define XOR_AND_semiring long long, add002, zero002, mul002, one002",
            "",
        ],
        "description": ""
    },


    "modpow_cpp": {
        "prefix": "modpow_cpp",
        "body": [
            "// a^b (mod m)",
            "long long modpow(long long a, long long b, long long mod){",
            "    long long res = 1;",
            "    a %= mod;",
            "    if (a == 0) return 0;",
            "    while (b){",
            "        if (b & 1) res = res * a % mod;",
            "        a = a * a % mod;",
            "        b >>= 1;",
            "    }",
            "    return res;",
            "}",
        ],
        "description": ""
    },
    
    "mod_nCk_nk_cpp": {
        "prefix": "modcmb_nCk_O(nk)_cpp",
        "body": [
            "// k ≤ n ≤ 5000  でPが素数でないとき",
            "const int MAX_N = 5000;",
            "const long long MOD = (long long)1e9+7;",
            "long long COM[MAX_N][MAX_N];",
            "// init_nCk: 二項係数のための前処理",
            "// 前処理の計算量: O(MAX_N*MAX_N)",
            "void init_nCk() {",
            "    memset(COM, 0, sizeof(COM));",
            "    COM[0][0] = 1;",
            "    rep(i, 1, MAX_N){",
            "        COM[i][0] = 1;",
            "        rep(j, 1, MAX_N){",
            "            COM[i][j] = (COM[i-1][j-1] + COM[i-1][j]) % MOD;",
            "        }",
            "    }",
            "}",
            "// nCk: MODでの二項係数を求める(前処理 int_nCk が必要)",
            "// クエリ計算量:O(1)",
            "long long nCk(int n, int k) {",
            "    assert(!(n < k));",
            "    assert(!(n < 0 || k < 0));",
            "    return COM[n][k];",
            "}",
        ],
        "description": ""
    },

    "mod_nCk_n_cpp": {
        "prefix": "modcmb_nCk_O(n)_cpp",
        "body": [
            "// k ≤ n ≤ 10^7  で法Pが素数のとき",
            "const long long MOD = (long long)1e9+7;",
            "vector<long long> fact, fact_inv, inv;",
            "// init_nCk: 二項係数のための前処理",
            "// 前処理の計算量: O(n)",
            "void init_nCk(int SIZE) {",
            "    fact.resize(SIZE + 5);",
            "    fact_inv.resize(SIZE + 5);",
            "    inv.resize(SIZE + 5);",
            "    fact[0] = fact[1] = 1;",
            "    fact_inv[0] = fact_inv[1] = 1;",
            "    inv[1] = 1;",
            "    for (int i = 2; i < SIZE + 5; i++) {",
            "        fact[i] = fact[i-1] * i % MOD;",
            "        inv[i] = MOD - inv[MOD%i] * (MOD/i) % MOD;",
            "        fact_inv[i] = fact_inv[i-1] * inv[i] % MOD;",
            "    }",
            "}",
            "// nCk: MODでの二項係数を求める(前処理 int_nCk が必要)",
            "// クエリ計算量: O(1)",
            "long long nCk(int n, int k) {",
            "    assert(!(n < k));",
            "    assert(!(n < 0 || k < 0));",
            "    return fact[n] * (fact_inv[k] * fact_inv[n-k] % MOD) % MOD;",
            "}",
        ],
        "description": ""
    },

    "mod_nCk_k_cpp": {
        "prefix": "modcmb_nCk_O(k)_cpp",
        "body": [
            "// n が固定かつ n が巨大 (k ≤ 10^7, n ≤ 10^9) で法 P が素数のとき",
            "const long long MOD = (long long)1e9+7;",
            "vector<long long> fact_inv, inv, COM;",
            "// init_nCk: 二項係数のための前処理",
            "// 前処理の計算量: O(k)",
            "void init_nCk(int n, int SIZE) {",
            "    fact_inv.resize(SIZE + 5);",
            "    inv.resize(SIZE + 5);",
            "    fact_inv[0] = fact_inv[1] = 1;",
            "    inv[1] = 1;",
            "    for (int i = 2; i < SIZE + 5; i++) {",
            "        inv[i] = MOD - inv[MOD % i] * (MOD / i) % MOD;",
            "        fact_inv[i] = fact_inv[i-1] * inv[i] % MOD;",
            "    }",
            "    COM.resize(SIZE + 5);",
            "    COM[0] = 1;",
            "    for (int i = 1; i < SIZE + 5; i++) {",
            "        COM[i] = COM[i-1] * ((n-i+1) * inv[i] % MOD) % MOD;",
            "    }",
            "}",
            "// nCk: MODでの二項係数を求める(前処理 int_nCk が必要)",
            "// クエリの計算量: O(1)",
            "long long nCk(int k) {",
            "    assert(!(k < 0));",
            "    return COM[k];",
            "}",
        ],
        "description": ""
    },

    "mod_nCk_k_2_cpp": {
        "prefix": "modcmb_nCk_O(k)_2_cpp",
        "body": [
            "// n が固定ではないかつ n が巨大 (k ≤ 10^7, n ≤ 10^9) で法 P が素数のとき",
            "const long long MOD = (long long)1e9+7;",
            "vector<long long> fact_inv, inv;",
            "// init_nCk: 二項係数のための前処理",
            "// 前処理の計算量: O(k)",
            "void init_nCk(int SIZE) {",
            "    fact_inv.resize(SIZE + 5);",
            "    inv.resize(SIZE + 5);",
            "    fact_inv[0] = fact_inv[1] = 1;",
            "    inv[1] = 1;",
            "    for (int i = 2; i < SIZE+5; i++) {",
            "        inv[i] = MOD - inv[MOD%i] * (MOD/i) % MOD;",
            "        fact_inv[i] = fact_inv[i-1] * inv[i] % MOD;",
            "    }",
            "}",
            "// nCk: MODでの二項係数を求める(前処理 int_nCk が必要)",
            "// クエリの計算量: O(k)",
            "long long nCk(int n, int k) {",
            "    assert(!(n < k));",
            "    assert(!(n < 0 || k < 0));",
            "    long long ans = 1;",
            "    for (int i = n; i >= n-k+1; i--) {",
            "        ans *= i;",
            "        ans %= MOD;",
            "    }",
            "    return ans * fact_inv[k] % MOD;",
            "}",
        ],
        "description": ""
    },


    "mint_nCk_cpp": {
        "prefix": "modcmb_nCk_mint",
        "body": [
            "// combination mod prime",
            "// https://youtu.be/8uowVvQ_-Mo?t=6002",
            "// https://youtu.be/Tgd_zLfRZOQ?t=9928",
            "struct modinv {",
            "    int n; vector<mint> d;",
            "    modinv(): n(2), d({0,1}) {}",
            "    mint operator()(int i) {",
            "        while (n <= i) d.push_back(-d[mint::mod()%n]*(mint::mod()/n)), ++n;",
            "        return d[i];",
            "    }",
            "    mint operator[](int i) const { return d[i];}",
            "} invs;",
            "struct modfact {",
            "    int n; vector<mint> d;",
            "    modfact(): n(2), d({1,1}) {}",
            "    mint operator()(int i) {",
            "        while (n <= i) d.push_back(d.back()*n), ++n;",
            "        return d[i];",
            "    }",
            "    mint operator[](int i) const { return d[i];}",
            "} facts;",
            "struct modfactinv {",
            "    int n; vector<mint> d;",
            "    modfactinv(): n(2), d({1,1}) {}",
            "    mint operator()(int i) {",
            "        while (n <= i) d.push_back(d.back()*invs(n)), ++n;",
            "        return d[i];",
            "    }",
            "    mint operator[](int i) const { return d[i];}",
            "} ifacts;",
            "mint comb(int n, int k) {",
            "    if (n < k || k < 0) return 0;",
            "    return facts(n)*ifacts(k)*ifacts(n-k);",
            "}",
            "",
        ],
        "description": ""
    },

    "nCk_pascal": {
        "prefix": "cmb_nCk_pascal",
        "body": [
            "/*",
            "    前処理: O(MAX_N*MAX_N)",
            "    nCk(n,k): nCk の計算。O(1)",
            "*/",
            "const int MAX_N = 60;         // n の最大値",
            "vector<vector<long long>> com;  // 前計算の結果を保存",
            "// 動的計画法で前処理",
            "void init() {",
            "    com.assign(MAX_N, vector<long long>(MAX_N));",
            "    com[0][0] = 1;",
            "    for (int i = 1; i < MAX_N; ++i) {",
            "        com[i][0] = 1;",
            "        for (int j = 1; j < MAX_N; j++) {",
            "            com[i][j] = (com[i - 1][j - 1] + com[i - 1][j]);",
            "        }",
            "    }",
            "}",
            "// nCk を取得",
            "long long nCk(int n, int k) {",
            "    assert(!(n < k));",
            "    assert(!(n < 0 || k < 0));",
            "    return com[n][k];",
            "}",
        ],
        "description": ""
    },

    "Eratosthenes_cpp": {
        "prefix": "eratosthenes_cpp",
        "body": [
            "vector<bool> eratosthenes(int N){",
            "    vector<bool> isprime(N+1, true);",
            "    isprime[0] = isprime[1] = false;",
            "    rep(p, 2, N+1){",
            "        if (!isprime[p]) continue;",
            "        int q = p + p;",
            "        while (q < N+1){isprime[q] = false; q += p;}",
            "    }",
            "    return isprime;",
            "}",
        ],
        "description": ""
    },

    "PrimeFactorization": {
        "prefix": "primeFactorization",
        "body": [
            "map<long long, int> primeFactorization(long long n){",
            "    map<long long, int> res;",
            "    for (long long i=2; i*i<=n; i++){",
            "        while (n % i == 0){ res[i]++; n /= i;}",
            "    }",
            "    if(n != 1) res[n] = 1;",
            "    return res;",
            "}",
        ],
        "description": ""
    },

    "Divisor": {
        "prefix": "divisor",
        "body": [
            "vector<long long> divisor(long long n){",
            "    vector<long long> res;",
            "    for (long long i = 1; i * i <= n; i++){",
            "        if (n % i == 0) {",
            "            res.push_back(i);",
            "            if (i * i != n) res.push_back(n / i);",
            "        }",
            "    }",
            "    sort(res.begin(), res.end());",
            "    return res;",
            "}",
        ],
        "description": ""
    },

    "RunLengthEncoding_cpp": {
        "prefix": "runLengthEncoding_cpp",
        "body": [
            "vector<pair<char, long long>> runLengthEncoding(string s){",
            "    long long n = s.length();",
            "    vector<pair<char, long long>> res;",
            "    long long l = 0;",
            "    while (l < n){",
            "        long long r = l + 1;",
            "        while (r < n && s[l] == s[r]) r++;",
            "        res.push_back(make_pair(s[l], r-l));",
            "        l = r;",
            "    }",
            "    return res;",
            "}",
        ],
        "description": ""
    },

    "Dijkstra": {
        "prefix": "dijkstra",
        "body": [
            "using P = pair<ll,ll>;",
            "vector<ll> dijkstra(vector<vector<P>> &graph, ll st = 0){",
            "    // graph: 重み付き連結リスト",
            "    ll sz = graph.size();",
            "    vector<ll> v(sz, INF);",
            "    priority_queue_rev<P> hq;",
            "    hq.push(make_pair(0, st));",
            "    while(!hq.empty()){",
            "        auto [d, now] = hq.top(); hq.pop();",
            "        if (v[now]!=INF) continue;",
            "        v[now] = d;",
            "        for (auto [nex, cost]: graph[now]){",
            "            if (v[nex]!=INF) continue;",
            "            hq.push(make_pair(d+cost, nex));",
            "        }",
            "    }",
            "    return v;",
            "}",
        ],
        "description": ""
    },


    "cum_cpp": {
        "prefix": "cum_cpp",
        "body": [
            "template<typename T>",
            "struct Cum{",
            "    vector<T> cum;",
            "    int n;",
            "    // コンストラクタ",
            "    Cum() {}",
            "    Cum(vector<T>& arr){",
            "        n = arr.size();",
            "        cum.resize(n+1,0);",
            "        // 累積和を計算",
            "        for (int i=0; i<n; i++){",
            "            cum[i+1] = cum[i] + arr[i];",
            "        }",
            "    }",
            "    // 0-indexed, 区間 [l,r) の和を取得",
            "    T get(int l, int r){",
            "        assert(l<=r);",
            "        return cum[r] - cum[l];",
            "    }",
            "    // 0-indexed, arr を連結した無限配列上で区間 [l,r) の和を取得",
            "    T get_overRange(ll l, ll r){",
            "        T cumr = get(0, n) * (r/(ll)n) + get(0, r%(ll)n);",
            "        T cuml = get(0, n) * (l/(ll)n) + get(0, l%(ll)n);",
            "        return cumr - cuml;",
            "    }",
            "};",
        ],
        "description": ""
    },

    "cum2D_cpp": {
        "prefix": "cum2D_cpp",
        "body": [
            "template<typename T>",
            "struct Cum2D{",
            "    vector<vector<T>> cum;",
            "    int h,w;",
            "    // コンストラクタ",
            "    Cum2D() {}",
            "    Cum2D(vector<vector<T>>& arr){",
            "        h = arr.size();",
            "        w = arr[0].size();",
            "        cum.resize(h+1, vector<T>(w+1, 0));",
            "        // 累積和を計算",
            "        for (int i=1; i<h+1; i++){",
            "            for (int j=1; j<w+1; j++){",
            "                cum[i][j] = arr[i-1][j-1] + cum[i][j-1] + cum[i-1][j] - cum[i-1][j-1];",
            "            }",
            "        }",
            "    }",
            "    // 0-indexed, 長方形領域 [h1,w1] から [h2,w2] までの和を取得",
            "    T get(int h1, int w1, int h2, int w2){",
            "        assert(h1<=h2 && w1<=w2);",
            "        return cum[h2+1][w2+1] - cum[h2+1][w1] - cum[h1][w2+1] + cum[h1][w1];",
            "    }",
            "    // 0-indexed, 無限グリッド（範囲外）にも対応、長方形領域 [h1,w1] から [h2,w2] までの和を取得",
            "    T get_overRange(long long h1, long long w1, long long h2, long long w2){",
            "        assert(h1<=h2 && w1<=w2);",
            "        auto f = [&](long long hh, long long ww){",
            "            T res = cum[h][w] * (hh/h) * (ww/w);",
            "            int remh = hh%h;",
            "            int remw = ww%w;",
            "            res += cum[remh][w] * (ww/w);",
            "            res += cum[h][remw] * (hh/w);",
            "            res += cum[remh][remw];",
            "            return res;",
            "        };",
            "        return f(h2+1, w2+1) - f(h2+1, w1) - f(h1, w2+1) + f(h1, w1);",
            "    }",
            "};",
            "",
        ],
        "description": ""
    },

    "lazySegTree_template_cpp": {
        "prefix": "lazySegTree_template_cpp",
        "body": [
            "// Verify: https://atcoder.jp/contests/abc322/tasks/abc322_f",
            "struct S",
            "{",
            "    bool all0, all1;",
            "    ll len;",
            "    ll l0, r0, mx0;",
            "    ll l1, r1, mx1;",
            "    S(){",
            "        all0 = true; all1 = true;",
            "        len = 0;",
            "        l0 = 0; r0 = 0; mx0 = 0;",
            "        l1 = 0; r1 = 0; mx1 = 0;",
            "    }",
            "    S(ll x){",
            "        all0 = (x==0); all1 = (x==1);",
            "        len = 1; ",
            "        l0 = x^1; r0 = x^1; mx0 = x^1;",
            "        l1 = x; r1 = x; mx1 = x;        ",
            "    }",
            "};",
            "",
            "S op(S l, S r){",
            "    S res;",
            "    res.all0 = l.all0 & r.all0;",
            "    res.all1 = l.all1 & r.all1;",
            "    res.l0 = l.l0;",
            "    if (l.all0) res.l0 += r.l0;",
            "    res.r0 = r.r0;",
            "    if (r.all0) res.r0 += l.r0;",
            "    res.l1 = l.l1;",
            "    if (l.all1) res.l1 += r.l1;",
            "    res.r1 = r.r1;",
            "    if (r.all1) res.r1 += l.r1;",
            "    res.mx0 = max({l.mx0, r.mx0, l.r0 + r.l0});",
            "    res.mx1 = max({l.mx1, r.mx1, l.r1 + r.l1});",
            "    return res;",
            "}",
            "",
            "S e(){",
            "    return S();",
            "}",
            "",
            "struct F",
            "{",
            "    bool flag;",
            "    F(bool x){ flag = x; }",
            "};",
            "",
            "S mp(F f, S x){",
            "    if (f.flag){",
            "        swap(x.all0, x.all1);",
            "        swap(x.l0, x.l1);",
            "        swap(x.r0, x.r1);",
            "        swap(x.mx0, x.mx1);",
            "    }",
            "    return x;",
            "}",
            "",
            "F comp(F f, F g){",
            "    f.flag ^= g.flag;",
            "    return f;",
            "}",
            "",
            "F id(){",
            "    return F(false);",
            "}",
            "",
            "int main()",
            "{",
            "    ll n,q;",
            "    cin>>n>>q;",
            "    string s;",
            "    cin>>s;",
            "    vector<S>a(n);",
            "    rep(i,0,n)a[i]=S(s[i]-'0');",
            "",
            "    lazy_segtree<S,op,e,F,mp,comp,id> seg(a);",
            "    while (q){",
            "        q--;",
            "        ll c;",
            "        cin>>c;",
            "        ll l,r;",
            "        cin>>l>>r;",
            "        l--;",
            "        if (c==1){",
            "            seg.apply(l,r,F(true));",
            "        }else{",
            "            cout << seg.prod(l,r).mx1 << endl;",
            "        }",
            "    }",
            "",
            "    return 0;",
            "}",
        ],
        "description": ""
    },

    "Euler_tour": {
        "prefix": "Euler_tour",
        "body": [
            "using P = pair<ll,ll>;",
            "P opmin(P a, P b){ return a.first < b.first ? a : b; }",
            "ll opsum(ll a, ll b){ return a + b; }",
            "P emin(){ return make_pair(INF, -1); }",
            "ll esum(){ return 0LL; }",
            "struct Euler_tour{",
            "    // https://qiita.com/recuraki/items/72e37eb9be9f71bc623a",
            "    vector<ll> vcost;",
            "    vector<ll> visit, vcost1, vcost2, ecost1, ecost2, depth;",
            "    ll step;",
            "    vector<ll> vdepth, in, out;",
            "    segtree<P,opmin,emin> RMQ;",
            "    segtree<ll,opsum,esum> RSQv1, RSQv2, RSQe1, RSQe2;",
            "    /*",
            "    visit: STEPで訪れた頂点の番号",
            "    vcost: 各頂点に与えられたコスト",
            "    vcost1: 初めて訪れた際のその頂点のコスト(本例では頂点コストは頂点番号に等しくしている)",
            "    vcost2: 初めて訪れた際のその頂点のコスト と 最後に訪れた際のコストをマイナスで記録したもの",
            "    ecost1: 初めて通った辺のコスト",
            "    ecost1: 初めて通った辺のコスト と 最後にその辺を訪れた時のコストをマイナスで記録したもの",
            "    深さ: 根を 0 とした時の頂点の深さ",
            "    dpeth: 各 STEP での深さ",
            "    vdepth: 各頂点の深さ",
            "    in: その頂点を最初に訪れた時間(STEP)",
            "    out: その頂点を抜けた時間(STEP) つまり、その頂点を最後に訪れた時間+1",
            "    RMQ: LCA(最小共通祖先) を管理",
            "    RSQv1: ある頂点を根とした部分木の頂点コストの総和を管理",
            "    RSQv2: ある頂点からある頂点へのパスの頂点コストの総和を管理",
            "    RSQe1: ある頂点を根とした部分木の辺コストの総和を管理",
            "    RSQe2: ある頂点からある頂点へのパスの辺コストの総和を管理",
            "    */",
            "    Euler_tour(ll n, ll st, vector<vector<ll>> g, vector<ll> cost){",
            "        // コンストラクタ、頂点にコストあり",
            "        // n: 頂点数、st: 根とする頂点、g: 連結リスト、cost: 各頂点のコスト",
            "        visit.resize(2*n);",
            "        vcost1.resize(2*n); vcost2.resize(2*n);",
            "        ecost1.resize(2*n); ecost2.resize(2*n);",
            "        depth.resize(2*n);",
            "        step = 0;",
            "        vdepth.resize(n, -1);",
            "        in.resize(n); out.resize(n);",
            "        vcost = cost;",
            "        function<void(ll,ll)> dfs = [&](ll now, ll d){",
            "            in[now] = step;",
            "            vdepth[now] = d;",
            "            visit[step] = now;",
            "            vcost1[step] = vcost[now];",
            "            vcost2[step] = vcost[now];",
            "            depth[step] = d;",
            "            step++;",
            "            for (auto nex: g[now]){",
            "                if (vdepth[nex] != -1) continue;",
            "                dfs(nex, d + 1);",
            "                visit[step-1] = now;",
            "            }",
            "            out[now] = step;",
            "            vcost2[step] = -vcost[now];",
            "            depth[step] = d - 1;",
            "            step++;",
            "        };",
            "        dfs(st, 0);",
            "        vector<P> v(2*n);",
            "        for (ll i=0; i<2*n; i++) v[i] = make_pair(depth[i], visit[i]);",
            "        RMQ = segtree<P,opmin,emin>(v);",
            "        RSQv1 = segtree<ll,opsum,esum>(vcost1);",
            "        RSQv2 = segtree<ll,opsum,esum>(vcost2);",
            "        RSQe1 = segtree<ll,opsum,esum>(ecost1);",
            "        RSQe2 = segtree<ll,opsum,esum>(ecost2);",
            "    }",
            "",
            "    Euler_tour(ll n, ll st, vector<vector<pair<ll,ll>>> g){",
            "        // コンストラクタ、辺にコストあり",
            "        // n: 頂点数、st: 根とする頂点、g: コスト付き連結リスト（pair型、first: 次の頂点、second: 辺のコスト)",
            "        visit.resize(2*n);",
            "        vcost1.resize(2*n); vcost2.resize(2*n);",
            "        ecost1.resize(2*n); ecost2.resize(2*n);",
            "        depth.resize(2*n);",
            "        step = 0;",
            "        vdepth.resize(n, -1);",
            "        in.resize(n); out.resize(n);",
            "        vcost.resize(n);",
            "        function<void(ll,ll)> dfs = [&](ll now, ll d){",
            "            in[now] = step;",
            "            vdepth[now] = d;",
            "            visit[step] = now;",
            "            depth[step] = d;",
            "            step++;",
            "            for (auto [nex,cost]: g[now]){",
            "                if (vdepth[nex] != -1) continue;",
            "                ll u = now;",
            "                ll v = nex;",
            "                if (u>v) swap(u, v);",
            "                ecost1[step] = cost;",
            "                ecost2[step] = cost;",
            "                dfs(nex, d + 1);",
            "                visit[step-1] = now;",
            "                ecost2[step-1] = -cost;",
            "            }",
            "            out[now] = step;",
            "            depth[step] = d - 1;",
            "            step++;",
            "        };",
            "        dfs(st, 0);",
            "        vector<P> v(2*n);",
            "        for (ll i=0; i<2*n; i++) v[i] = make_pair(depth[i], visit[i]);",
            "        RMQ = segtree<P,opmin,emin>(v);",
            "        RSQv1 = segtree<ll,opsum,esum>(vcost1);",
            "        RSQv2 = segtree<ll,opsum,esum>(vcost2);",
            "        RSQe1 = segtree<ll,opsum,esum>(ecost1);",
            "        RSQe2 = segtree<ll,opsum,esum>(ecost2);",
            "    }",
            "",
            "    // a,b の LCA(最小共通祖先) を求める",
            "    ll lca(ll a, ll b){",
            "        ll l = min(in[a], in[b]);",
            "        ll r = max(out[a], out[b]);",
            "        auto res = RMQ.prod(l, r);",
            "        return res.second;",
            "    }",
            "    ll get_subtree_vsum(ll a){",
            "        return RSQv1.prod(in[a], out[a]);",
            "    }",
            "    ll get_subtree_esum(ll a){",
            "        return RSQe1.prod(in[a]+1, out[a]);",
            "    }",
            "    ll rootpath_vsum(ll a){",
            "        return RSQv2.prod(0, in[a]+1);",
            "    }",
            "    ll rootpath_esum(ll a){",
            "        return RSQe2.prod(1, in[a]+1);",
            "    }",
            "    ll get_path_vsum(ll a, ll b){",
            "        ll par = lca(a, b);",
            "        return rootpath_vsum(a) + rootpath_vsum(b) - 2*rootpath_vsum(par) + vcost[par];",
            "    }",
            "    ll get_path_esum(ll a, ll b){",
            "        ll par = lca(a, b);",
            "        return rootpath_esum(a) + rootpath_esum(b) - 2*rootpath_esum(par);",
            "    }",
            "    void update_v(ll a, ll x){",
            "        // 頂点 a のコストを x に置換",
            "        vcost[a] = x;",
            "        RSQv1.set(in[a], x);",
            "        RSQv2.set(in[a], x);",
            "        RSQv2.set(out[a], -x);",
            "    }",
            "    void update_e(ll a, ll b, ll x){",
            "        // 辺 a-b のコストを x に置換",
            "        if (in[a] > in[b]) swap(a, b);",
            "        RSQe1.set(in[b], x);",
            "        RSQe2.set(in[b], x);",
            "        RSQe2.set(out[b], -x);",
            "    }",
            "};",
        ],
        "description": ""
    },

    "Mo's algorithm": {
        "prefix": "Mo's algorithm",
        "body": [
            "/*",
            "Mo's アルゴリズム",
            "verify: https://atcoder.jp/contests/abc174/tasks/abc174_f",
            "参考: https://ei1333.hateblo.jp/entry/2017/09/11/211011",
            "1. 配列の要素が不変",
            "2. クエリを先読みできる",
            "3. 区間 [l,r) の結果から区間[l+1,r), [l-1,r), [l,r-1), [l,r+1) の結果を計算できる",
            "*/ ",
            "int n,q;",
            "cin >> n >> q;",
            "vector<int> a(n);",
            "rep(i,0,n) cin >> a[i];",
            "rep(i,0,n) a[i]--;",
            "",
            "int window = max(1, int(n/sqrt(q))); // 区間を区切る領域サイズ",
            "int nl = 0, nr = 0; // [nl, nr): 現在の計算済み区間",
            "vector<ll> res(q); // 各クエリの結果を格納する配列",
            "",
            "// 問題に応じて書き換える",
            "vector<int> cnt(2000200); // cnt[i]: 区間内に i が何個あるか",
            "int num_kind = 0; // 区間内に何種類の数があるか",
            "vector<int> cnt_kind(n+1); // 区間内に c 個ある数が何種類あるか",
            "int mode = 0; // 最頻値の出現回数",
            "",
            "// index: 各クエリのインデックスを管理する配列",
            "vector<int> l(q), r(q), index(q);",
            "rep(i,0,q){",
            "    cin >> l[i] >> r[i];",
            "    l[i]--;",
            "}",
            "for (int i=0; i<q; i++) index[i] = i;",
            "",
            "// ソート",
            "sort(all(index), [&](int a, int b){",
            "    if (l[a]/window != l[b]/window) return l[a] < l[b];",
            "    if (l[a]/window % 2) return r[a] > r[b];",
            "    else return r[a] < r[b];",
            "});",
            "",
            "// 問題に応じて書き換える",
            "auto add = [&](int idx){",
            "    int x = a[idx];",
            "    if (cnt[x] == 0) num_kind++;",
            "    cnt_kind[cnt[x]]--;",
            "    cnt[x]++;",
            "    cnt_kind[cnt[x]]++;",
            "    mode = max(mode, cnt[x]);  ",
            "};",
            "",
            "// 問題に応じて書き換える",
            "auto del = [&](int idx){",
            "    int x = a[idx];",
            "    cnt_kind[cnt[x]]--;",
            "    if(cnt[x] == mode && cnt_kind[cnt[x]] == 0) mode--;",
            "    cnt[x]--;",
            "    cnt_kind[cnt[x]]++;",
            "    if (cnt[x] == 0) num_kind--;",
            "};",
            "",
            "for (auto nex: index){",
            "    // クエリの区間に一致するまで、現在の区間を拡張 or 縮小",
            "    while (nl > l[nex]) add(--nl);",
            "    while (nr < r[nex]) add(nr++);",
            "    while (nl < l[nex]) del(nl++);",
            "    while (nr > r[nex]) del(--nr);",
            "",
            "    // 問題に応じて書き換える",
            "    // クエリの計算結果",
            "    res[nex] = num_kind;",
            "}",
            "",
            "rep(i,0,q) cout << res[i] << endl;",
            "",
        ],
        "description": ""
    },

    "Potential_union_find": {
        "prefix": "Potential_union_find",
        "body": [
            "// これは窃盗したライブラリ",
            "// 窃盗元: https://atcoder.jp/contests/abc328/submissions/47469055",
            "//【ポテンシャル Union-Find】",
            "/*",
            "* Potential_union_find<T>(int n) : O(n)",
            "*	非連結で大きさ n の重み付き Union-Find を構築する．",
            "*",
            "* bool set_diff(int a, int b, T d) : O(α(n))",
            "*	v[b] - v[a] = d という関係を追加する．失敗は false を返す．",
            "*",
            "* bool same(int a, int b) : O(α(n))",
            "*	頂点 a と頂点 b が同じ連結成分に属するかを返す．",
            "*",
            "* T get_diff(int a, int b) : O(α(n))",
            "*	v[b] - v[a] を返す．（差が未確定なら -INFL）",
            "*",
            "* int leader(int a) : O(α(n))",
            "*	頂点 a の属する連結成分の親を返す．",
            "*",
            "* int size(int a) : O(α(n))",
            "*	頂点 a の属する連結成分の大きさを返す．",
            "*",
            "* int size() : O(1)",
            "*	連結成分の個数を返す．",
            "*",
            "* vv<piT> groups() : O(n α(n))",
            "*	連結成分の (頂点番号, ポテンシャル) の組のリストを返す．",
            "*/",
            "template <class T>",
            "class Potential_union_find {",
            "	int n; // 頂点の個数",
            "	int m; // 連結成分の個数",
            "",
            "	// parent_or_size[i] : 頂点 i の親または集合の大きさ",
            "	// 頂点 i が根でない場合は親の番号（非負）を，",
            "	// 根の場合は属する連結成分の大きさの -1 倍（負）を表す．",
            "	vector<int> parent_or_size;",
            "",
            "	// pot[i] : 親からみた頂点 i への差",
            "	// 短絡後に参照すれば，根からみた頂点 i への差（ポテンシャル）になる．",
            "	vector<T> pot;",
            "",
            "public:",
            "	// 非連結で大きさ n のポテンシャル Union-Find を構築する．",
            "	Potential_union_find(int n_) : n(n_), m(n), parent_or_size(n, -1), pot(n) {}",
            "	Potential_union_find() : n(0), m(0) {}",
            "",
            "	// 頂点 a, b 間の差 v[b] - v[a] を設定する．",
            "	bool set_diff(int a, int b, T d) {",
            "		// verify : https://atcoder.jp/contests/abc320/tasks/abc320_d",
            "",
            "		// 頂点 a, b の属する連結成分の根 ra, rb を得る．",
            "		int ra = leader(a);",
            "		int rb = leader(b);",
            "",
            "		// 根が同じであれば既に連結であるから何もしない．",
            "		// 既にある関係と整合しているかを返す．",
            "		if (ra == rb) return pot[b] - pot[a] == d;",
            "",
            "		// 根が異なる場合，大きい連結成分の根を改めて ra，小さい方を rb とする．",
            "		if (-parent_or_size[ra] < -parent_or_size[rb]) {",
            "			swap(a, b);",
            "			swap(ra, rb);",
            "			d *= -1;",
            "		}",
            "",
            "		// 小さい方の連結成分を ra を根とする連結成分に統合する．",
            "		parent_or_size[ra] += parent_or_size[rb];",
            "		parent_or_size[rb] = ra;",
            "		pot[rb] = pot[a] - pot[b] + d;",
            "",
            "		// 連結成分の数を 1 つ減らす．",
            "		m--;",
            "",
            "		return true;",
            "	}",
            "",
            "	// 頂点 a, b が同じ連結成分に属するかを返す．",
            "	bool same(int a, int b) {",
            "		// verify : https://atcoder.jp/contests/abc320/tasks/abc320_d",
            "",
            "		// 根が同じなら連結である．",
            "		return leader(a) == leader(b);",
            "	}",
            "",
            "	// v[b] - v[a] を返す．",
            "	T get_diff(int a, int b) {",
            "		// verify : https://atcoder.jp/contests/abc320/tasks/abc320_d",
            "",
            "		if (!same(a, b)) return T(INF);",
            "",
            "		// 根からの差の差として計算する．",
            "		return pot[b] - pot[a];",
            "	}",
            "",
            "	// 頂点 a の属する連結成分の根を返す．",
            "	int leader(int a) {",
            "		// a が根であれば自分自身を返す．",
            "		int pa = parent_or_size[a];",
            "		if (pa < 0) return a;",
            "",
            "		// a が根でなければ，a の親 pa の根 ra を求める．",
            "		// 再帰的な処理が回り，pa の親は ra になっていることに注意．",
            "		int ra = leader(pa);",
            "",
            "		// a の親を ra に更新しつつ，a の根 ra を返す．",
            "		parent_or_size[a] = ra;",
            "		pot[a] += pot[pa];",
            "		return ra;",
            "	}",
            "",
            "	// 頂点 a の属する連結成分の大きさを返す．",
            "	int size(int a) {",
            "		// a の根を調べ，そこに記録されている大きさの情報を返す．",
            "		return -parent_or_size[leader(a)];",
            "	}",
            "",
            "	// 連結成分の個数を返す．",
            "	int size() {",
            "		// verify : https://yukicoder.me/problems/no/2251",
            "",
            "		return m;",
            "	}",
            "",
            "	// 連結成分の (頂点番号, ポテンシャル) の組のリストを返す．",
            "	vector<vector<pair<int, T>>> groups() {",
            "		// verify : https://atcoder.jp/contests/code-festival-2016-quala/tasks/codefestival_2016_qualA_d",
            "",
            "		vector<vector<pair<int, T>>> res(m);",
            "",
            "		vector<int> r_to_i(n, -1); int i = 0;",
            "		rep(a, 0, n) {",
            "			int r = leader(a);",
            "			if (r_to_i[r] == -1) r_to_i[r] = i++;",
            "			res[r_to_i[r]].emplace_back(a, pot[a]);",
            "		}",
            "",
            "		return res;",
            "	}",
            "};",
        ],
        "description": ""
    },

    "Tentousuu Inversion Number": {
        "prefix": "Tentousuu Inversion Number",
        "body": [
            "ll op(ll a, ll b){ return a+b; }",
            "ll e(){ return 0LL; }",
            "ll Tentou(vector<ll> arr){",
            "    ll n = arr.size();",
            "    ll mx = *max_element(all(arr));",
            "    segtree<ll,op,e> seg(mx+1);",
            "    ll res = 0;",
            "    rep(i,0,n){",
            "        res += seg.prod(arr[i]+1,mx+1);",
            "        seg.set(arr[i], seg.get(arr[i])+1);",
            "    }",
            "    return res;",
            "}",
        ],
        "description": ""
    },

    "CC Coodinate Compression": {
        "prefix": "CC Coodinate Compression",
        "body": [
            "// Coodinate Compression",
            "// https://youtu.be/fR3W5IcBGLQ?t=8550",
            "template<typename T=ll>",
            "struct CC {",
            "    bool initialized;",
            "    vector<T> xs;",
            "    CC(): initialized(false) {}",
            "    void add(T x) { xs.push_back(x);}",
            "    void init() {",
            "        sort(xs.begin(), xs.end());",
            "        xs.erase(unique(xs.begin(),xs.end()),xs.end());",
            "        initialized = true;",
            "    }",
            "    int operator()(T x) {",
            "        if (!initialized) init();",
            "        // lower_bound に修正",
            "        return lower_bound(xs.begin(), xs.end(), x) - xs.begin();",
            "    }",
            "    T operator[](ll i) {",
            "        if (!initialized) init();",
            "        return xs[i];",
            "    }",
            "    ll size() {",
            "        if (!initialized) init();",
            "        return xs.size();",
            "    }",
            "};",
        ],
        "description": ""
    },

    "ReRootingDP": {
        "prefix": "rerootingDP",
        "body": [
            "template <class E, class V, E (*merge)(E, E), E (*e)(), E (*put_edge)(V, int), V (*put_vertex)(E, int)>",
            "struct RerootingDP {",
            "    struct edge {",
            "        int to, idx, xdi;",
            "    };",
            "    RerootingDP(int n_ = 0) : n(n_), inner_edge_id(0) {",
            "        es.resize(2*n-2);",
            "        start.resize(2*n-2);",
            "        if (n == 1) es_build();",
            "    }",
            "    void add_edge(int u, int v, int idx, int xdi){",
            "        start[inner_edge_id] = u;",
            "        es[inner_edge_id] = {v,idx,xdi};",
            "        inner_edge_id++;",
            "        start[inner_edge_id] = v;",
            "        es[inner_edge_id] = {u,xdi,idx};",
            "        inner_edge_id++;",
            "        if (inner_edge_id == 2*n-2){",
            "            es_build();",
            "        }",
            "    }",
            "    vector<V> build(int root_ = 0){",
            "        root = root_;",
            "        vector<V> subdp(n); subdp[0] = put_vertex(e(),0);",
            "        outs.resize(n);",
            "        vector<int> geta(n+1,0);",
            "        for (int i = 0; i < n; i++) geta[i+1] = start[i+1] - start[i] - 1;",
            "        geta[root+1]++;",
            "        for (int i = 0; i < n; i++) geta[i+1] += geta[i];",
            "        auto dfs = [&](auto sfs, int v, int f) -> void {",
            "            E val = e();",
            "            for (int i = start[v]; i < start[v+1]; i++){",
            "                if (es[i].to == f){",
            "                    swap(es[start[v+1]-1],es[i]);",
            "                }",
            "                if (es[i].to == f) continue;",
            "                sfs(sfs,es[i].to,v);",
            "                E nval = put_edge(subdp[es[i].to],es[i].idx);",
            "                outs[geta[v]++] = nval;",
            "                val = merge(val,nval);",
            "            }",
            "            subdp[v] = put_vertex(val, v);",
            "        };",
            "        dfs(dfs,root,-1);",
            "        return subdp;",
            "    }",
            "    vector<V> reroot(){",
            "        vector<E> reverse_edge(n);",
            "        reverse_edge[root] = e();",
            "        vector<V> answers(n);",
            "        auto dfs = [&](auto sfs, int v) -> void {",
            "            int le = outs_start(v);",
            "            int ri = outs_start(v+1);",
            "            int siz = ri - le;",
            "            vector<E> rui(siz+1);",
            "            rui[siz] = e();",
            "            for (int i = siz-1; i >= 0; i--){",
            "                rui[i] = merge(outs[le+i],rui[i+1]);",
            "            }",
            "            answers[v] = put_vertex(merge(rui[0],reverse_edge[v]),v);",
            "            E lui = e();",
            "            for (int i = 0; i < siz; i++){",
            "                V rdp = put_vertex(merge(merge(lui,rui[i+1]),reverse_edge[v]),v);",
            "                reverse_edge[es[start[v]+i].to] = put_edge(rdp,es[start[v]+i].xdi);",
            "                lui = merge(lui,outs[le+i]);",
            "                sfs(sfs,es[start[v]+i].to);",
            "            }",
            "        };",
            "        dfs(dfs,root);",
            "        return answers;",
            "    }",
            "    private:",
            "    int n, root, inner_edge_id;",
            "    vector<E> outs;",
            "    vector<edge> es;",
            "    vector<int> start;",
            "    int outs_start(int v){",
            "        int res = start[v] - v;",
            "        if (root < v) res++;",
            "        return res;",
            "    }",
            "    void es_build(){",
            "        vector<edge> nes(2*n-2);",
            "        vector<int> nstart(n+2,0);",
            "        for (int i = 0; i < 2*n-2; i++) nstart[start[i]+2]++;",
            "        for (int i = 0; i < n; i++) nstart[i+1] += nstart[i];",
            "        for (int i = 0; i < 2*n-2; i++) nes[nstart[start[i]+1]++] = es[i];",
            "        swap(es,nes);",
            "        swap(start,nstart);",
            "    }",
            "};",
            "",
            "// https://atcoder.jp/contests/abc348/tasks/abc348_e",
            "using P = pair<ll,ll>;",
            "P merge(P a, P b){",
            "    return {a.first + b.first, a.second + b.second};",
            "}",
            "P e(){",
            "    return {0LL, 0LL};",
            "}",
            "vector<ll> cost;",
            "P put_edge(P v, int i){",
            "    return {v.first+v.second, v.second};",
            "}",
            "P put_vertex(P e, int v){",
            "    return {e.first, e.second + cost[v]};",
            "}",
            "",
            "int main()",
            "{",
            "    ios::sync_with_stdio(false);",
            "    std::cin.tie(nullptr);",
            "",
            "    ll n;",
            "    cin>>n;",
            "    cost.resize(n);",
            "    RerootingDP<P,P,merge,e,put_edge,put_vertex> g(n);",
            "    rep(i,0,n-1){",
            "        ll a,b;",
            "        cin>>a>>b;",
            "        a--;b--;",
            "        g.add_edge(a,b,i,i);",
            "    }",
            "    rep(i,0,n)cin>>cost[i];",
            "    g.build();",
            "    vector<P> arr = g.reroot();",
            "    ll ans = INF;",
            "    for (auto a: arr){",
            "        chmin(ans, a.first);",
            "    }",
            "    cout << ans << endl;",
            "    ",
            "    return 0;",
            "}",
        ],
        "description": ""
    },

}
